ID	Title	Description
1	Categorise words by part-of-speech	The objective of this task is to take a frequency list of words for AAA and categorise them by their part-of-speech. Further information can be found on the following page: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Categorise_words_from_frequency_list . You will need to have some knowledge of the language whose words you intend to categorise
2	Lemmatise words by frequency	The objective of this task is to take a frequency list of words for AAA which have been categorised and then lemmatise them. This means finding the "base" or "dictionary" form of the word. Further information can be found on the following page: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Lemmatise_words_from_frequency_list . You will need to have some knowledge of the language whose words you intend to lemmatise.
3	Intersection of ATT format transducers 	The objective of these tasks is to write code to intersect two finite-state transducers. The first transducer is a bilingual dictionary that has been converted into prefixes and the second transducer is the monolingual dictionary. You can find out more about the task on this web page: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Intersection_of_ATT_format_transducers
4	Categorise words by inflectional paradigm	The objective of this task is to find the inflectional paradigm for a series of words in AAA. This can be done manually, or semi-automatically. The following page has further details: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Add_words_from_frequency_list
5	Extract (scrape) inflections from Wiktionary	The objective of this task is to extract (or scrape) inflectional information for AAA from Wiktionary. This will involve either processing wiki code or HTML code. Further information can  be found at the following link: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Scrape_inflection_information_from_Wiktionary
6	Language detection in apertium-apy	The objective of this task is to add a function to do language detection to <a href="http://wiki.apertium.org/wiki/Apertium-apy">apertium-apy</a>, a python based web services API for Apertium. Further information at the following URL: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Language_detection_in_simple-html_and_apertium-apy
7	Localised 'available languages' in apertium-apy	The objective of this task is to make a new function to return a list of available languages in translation in apertium-apy, a python-based web-services API for Apertium. Further information can be found at the following URL: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Language_detection_in_simple-html_and_apertium-apy
8	Hand-annotate 500 words of text	The objective of this task is to manually morphologically disambiguate running words of text in AAA. More information can be found on the Wiki here: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Morphologically_disambiguating_text
9	Abstract formatting for the simple-html interface	 The <a href="http://wiki.apertium.org/wiki/Simple-html">simple-html</a> interface should be easily customisable so that people can make it look how they want. The task is to abstract the formatting and make one or more new stylesheets to change the appearance. This is basically making a way of "skinning" the interface. 
10	Interface behaviour for language detection	The objective of this task is to improve the behaviour of the interface for selecting languages in the simple-html interface for Apertium. It will involve using JavaScript and CSS to choose the most probable language and to highlight other probable languages. Further information can be found here: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Language_detection_in_simple-html_and_apertium-apy
11	Use external language detection in simple-html	 Make <a href="http://wiki.apertium.org/wiki/Simple-html">simple-html</a> interface not use 2.9MB javascript module for language detection/identification.  Instead it should query <a href="http://wiki.apertium.org/wiki/Apertium-apy" title="Apertium-apy">apertium-apy</a> with text to get a list of languages with probabilities. 
12	Wiktionary language-page count calculator	The objective of this task is to write a script which calculates the number of pages in a Wiktionary category for a language. The code should be modular, able to work with any given Wiktionary, and should return e.g. the number of pages in Category:Faroese_language. 
13	Bison syntax-tree visualisation	Write a program which reads a grammar using bison, parses a sentence and outputs the syntax tree as text, or graphViz or something. You can find more information here: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Syntax_tree_printing_in_bison
14	Document how to install WikiBhasha	
15	Intersection of two transducers in lttoolbox	The objective of this tasks is to write code in C++ using the lttoolbox library to intersect two finite-state transducers. The first transducer is a bilingual dictionary that has been converted into prefixes and the second transducer is the monolingual dictionary. You can find out more about the task on this web page: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Intersection_of_ATT_format_transducers
16	Front end to intersection in lttoolbox (lt-trim)	The objective of this task is to write a C++ program that provides a front end to intersect two transducers. You can find out more at: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Intersection_of_ATT_format_transducers
17	Extract translations from Wiktionary	For language pair AAA and BBB extract all the possible translations from Wiktionary. You could do this with a screenscraping or a databases/wikicode parsing methodology. 
18	Extract paradigm sketches from a dictionary	The objective of this task is to extract paradigm "sketches" for AAA of the kind found in dictionaries and sort them into the different categories. It will involve text processing and quite a bit of shell scripting or python. For more information see: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Extracting_paradigm_sketches_from_dictionaries
19	Morphologically analyse and align parallel corpus	The objective of this task is to take a parallel corpus for AAA and BBB and to morphologically analyse it using Apertium and then word-align it, for example using GIZA++. 
20	Hand-annotate 250 words of text	The objective of this task is to manually morphologically disambiguate 250 words of running words of text in AAA. More information can be found on the Wiki here: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Morphologically_disambiguating_text
21	Extract parallel corpus from web site	The objective of this task is to download web pages from a bilingual (or multilingual) web site and document align them. This means finding out which pages are translations of other pages.
22	Sentence align parallel corpus	Given a document-aligned parallel corpus, use a sentence splitter (for example NLTK Punkt) and sentence aligner (for example hunalign) to produce a sentence-aligned parallel corpus.
23	Hand-correct the spelling of 50 words	The objective of this task is to read through documents (e.g. from Wikipedia) and find and correct spelling errors in them, keeping a note of where you found the error. For further information see: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Hand-correct_spelling_errors
24	Document how to install a voikko spellchecker for LibreOffice	The objective of this task is to document how to install a spellchecker using libvoikko and LibreOffice for language AAA. For further information, contact your mentor.
25	Document how to install a voikko spellchecker for libenchant	The objective of this task is to document how to install a spellchecker using libvoikko and libenchant for language AAA. For further information, contact your mentor.
26	Convert paradigm tables to speling format	The objective of this task is to take a grammar for AAA and copy out (or extract) the paradigms in speling format. A description of the speling format can be found here: http://wiki.apertium.org/wiki/Speling_format. Your mentor will provide you with the grammar.
27	Check output of a word-aligner to make a bilingual dictionary	The objective of this task is to check the output of a word aligner in order to make a bilingual dictionary between AAA and BBB. For further information see: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Check_output_of_word_aligner
28	Manually create a transfer lexicon from a word list in .dix format	The objective of this task is to manually create a transfer lexicon for AAA and BBB. A transfer lexicon is a file that includes words, their equivalents in another language, and tags describing some kinds of structural transfer that might need to take place. 
29	Proofread an existing dictionary	The objective of this task is to read through an existing dictionary for AAA and BBB and check that the entries are accurate and complete. If an entry is wrong, you should change it, if it is incomplete you should add the missing entries. Contact your mentor on IRC for a copy of the dictionary.
30	Extract test sentences from a grammar	The objective of this task is to read through a grammar of AAA in BBB and to extract test sentences. Test sentences are short sentences, of under 10 words which demonstrate grammatical differences. Talk to your mentor for details on how to encode the test sentences.
31	Document how to set up libreoffice-voikko in Windows	
32	Document how to use WikiBhasha	
33	Write a dictionary-based tokeniser for Asian languages	The objective of this task is to write a tokeniser for AAA. A tokeniser takes a sentence and splits it into words. One of the challenges of building a tokeniser for AAA is that spaces are not used to separate words. The tokeniser will have some generic code for reading and writing output, and will use one or more algorithms to determine how to segment the sentence. Read more about this task here: http://wiki.apertium.org/wiki/Task_ideas_for_Google_Code-in/Tokenisation_for_spaceless_orthographies
34	Evaluate tokenisation strategies for a South-Asian language	
		
