#!/usr/bin/env python3

from __future__ import print_function
import os
import sys
from queue import Queue # A queue type to communicate between threads
import threading # A simple thread launcher
from configparser import ConfigParser
# The ConfigParser is used to store preferences of the program

# GTK related imports
from gi.repository import GObject
from gi.repository import Gtk
import gi

#If you want to test out the program without using Dbus, set usingDbus to False
usingDbus = True
try:
    import dbus # Used to connect to the Apertium D-Bus service
except:
    usingDbus = False

import tolk
apertium_dir = tolk.prefix
lang_names = tolk.lang_names

def split_pair_into_from_and_to(modes):
    """Return a list of from-languages and a dictionary of to-languages.
    The dictionary maps from-languages to all of their to-languages.

    We also want to store it in a Gtk ListStore to make things easier for ourselves.
    """
    to = {}
    fro = Gtk.ListStore(str, str)
    froSet = set() #Let's keep a running set of the from-languages we've used
                    #so we don't reuse them.
    for mode in sorted(modes):
        if mode.count("-") > 1:
            continue #some modes like val-en-ca or en-ca-multi should be ignored
        locSplit = mode.find("-")

        #Find the from language
        froLang = mode[:locSplit]
        if froLang in lang_names:
            froLangFriendlyName = tolk.lang_names[froLang]
        else:
            froLangFriendlyName = froLang
        if froLang not in froSet: #check if we've already added it
            fro.append([froLang, froLangFriendlyName])
            froSet.add(froLang)
        print(froLang, froLangFriendlyName, file=sys.stderr)

        #Find the to language
        toLang = mode[locSplit + 1:]
        if toLang in lang_names:
            toLangFriendlyName = lang_names[toLang]
        else:
            toLangFriendlyName = toLang

        #Add the to language to our dictionary of list models
        if froLang in to:
            to[froLang].append([toLang, toLangFriendlyName])
            print(toLang, toLangFriendlyName, file=sys.stderr)
        else:
            to[froLang] = Gtk.ListStore(str, str)
            to[froLang].append([toLang, toLangFriendlyName])
            to[froLang].set_sort_column_id(1, Gtk.SortType.ASCENDING)
        fro.set_sort_column_id(1, Gtk.SortType.ASCENDING)
    return fro, to

class MainWindow:
    def get_modes(self):
        """Get the translation-pairs (modes) available on the system without dbus.
        """
        modes = []
        mode_directory = os.path.join(apertium_dir, "share", "apertium", "modes")

        for dirent in os.listdir(mode_directory):
            fname, ext = os.path.fname, ext = os.path.splitext(dirent)
            if ext == ".mode":
                modes.append(fname)

        return modes
        
    
    def setup_combo(self, combo):
        """Set the combo box up to display simple a list of text and
        add everything in 'modes' to the list.
        """
        
        combo.set_model(self.fro)
        combo.set_wrap_width(int(len(self.fro) / 6) + 1)

        combo.set_active(0) # Set the combobox to the first entry

        return combo


    def options(self):
        if self.chkMarkUnknown.get_active():
            return {"mark_unknown": "true"}
        else:
            return {"mark_unknown": "false"}


    def load_config(self):
        """Read the configuration data. First read default data from 'defaults.cfg'
        and then user config data from '~/.apertium-tolk.cfg'. Tell the
        glade object to update stored widget properties based on the config data.
        """
        self.glade.load_gtk_state_default(self.config)
        self.config.read([os.path.expanduser('~/.apertium-tolk.cfg')])
        self.glade.load_gtk_state(self.config)

    def save_config(self):
        """Store the configuration data to the user file '~/.apertium-tolk.cfg'.
        Before storing, tell the glade object to dump the widget state to the configuration
        object self.config.
        """
        self.glade.dump_gtk_state(self.config)
        f = open(os.path.expanduser('~/.apertium-tolk.cfg'), 'w')
        self.config.write(f)
        f.close()
    
    def __init__(self, path):
        global usingDbus
        self.config = ConfigParser() # An object which loads/stores preferences
        try:
            self.bus = dbus.SessionBus()
            # Create a proxy object to the D-Bus object org.apertium.info/ using the interface org.apertium.Info
            self.info = dbus.Interface(self.bus.get_object("org.apertium.info", "/"), "org.apertium.Info")
        except:
            usingDbus = False
        self.input_queue = Queue()  # Thread communication queue
        self.glade = tolk.GladeXML() # Instantiate our custom Glade class which extends the Gtk.glade.GladeXML class
        self.glade.add_from_file(path)
        self.glade.connect_signals(self);   # Try to connect the signals defined in the glade file to methods defined in self

        # Get handles objects of interest in the glade file
        self.buffer         = self.glade.get_object("txtInput").get_buffer()
        self.output_buffer  = self.glade.get_object("txtOutput").get_buffer()
        self.wndMain        = self.glade.get_object("wndMain")
        self.dlgAbout       = self.glade.get_object("dlgAbout")
        self.chkMarkUnknown = self.glade.get_object("chkMarkUnknown")

        #Let's cache the languages at the beginning of the program
        if usingDbus:
            try:
                modes = self.info.modes()
            except:
                usingDbus = False
        else:
            modes = self.get_modes()

        self.fro, self.to = split_pair_into_from_and_to(modes)
        
        self.comboPair      = self.setup_combo(
                                self.glade.get_object("comboPair"))

        self.buffer.connect("changed", self.on_buffer_changed)

        # Start the thread which will handle
        thread = threading.Thread(target=self.translator_loop)
        thread.start()

        self.load_config()
        self.wndMain.show_all()

        
    def translator_loop(self):
        """This runs as a thread which invokes Apertium D-Bus methods.
        If Apertium-Dbus is not on the system, call apertium ourself.

        We run this in a thread, since it takes a perceptible amount
        of time to execute an Apertium call.

        Only one Apertium call at most is ever active. We ensure this by
        running only one thread. This thread receives updates via a queue.

        While it is busy waiting for an Apertium call to return, its
        update queue might receive requests (this happens when the user is
        typing while Apertium is running). We're only ever interested in the
        latest item added to the queue, so we discard everything up to that
        point.
        """
        global usingDbus
        while True:
            options, _input = self.input_queue.get() # Block waiting for something to translate
            while not self.input_queue.empty():          # We're only interested in the latest item in the queue...
                options, _input = self.input_queue.get() # ...so we discard items until we have the latest item
            if (options, _input) == (None, None): #We send (None, None) to the queue to tell it to stop the thread
                break
            result = ''
            
            def update_text():
                """Take the output from the translation and update the output buffer"""
                self.output_buffer.set_text(result)
                return False
            if usingDbus:
                try:
                    result = self.translator.translate(options, _input) # Invoke the Apertium D-Bus translation service
                except Exception as e:
                    usingDbus = False
                    print(e, file=sys.stderr) # We should probably do exit(1) here

            else: # we will have to call apertium ourselves
                from subprocess import Popen, PIPE

                if options['mark_unknown'] == 'true': #careful: this is actually a string
                    m_unknown = True
                else:
                    m_unknown = False
                
                #this is the command we will send:
                cmd = "apertium " + self.lang_pair
                if not m_unknown:
                    cmd += ' -u' #this is tricky: -u indicates _not_ to mark

                #calling on apertium
                p = Popen(cmd, shell=True,stdin=PIPE, stdout=PIPE, stderr=PIPE,
                    close_fds=True)
                (child_in, child_out, child_err) = (p.stdin, p.stdout, p.stderr)
                child_in.write(bytes(_input, 'UTF-8'))
                child_in.close() # You MUST close the child's stdin to get output from some programs

                result = child_out.read().decode('UTF-8')
                child_out.close()
                err = child_err.read().decode('UTF-8')
                child_err.close()

                #If there's an error, display it:
                #TODO: make it red.
                if err:
                    result = err
                
            GObject.idle_add(update_text) # Post the function into the GTK main loop
                

    def on_buffer_changed(self, w):
        nex = [self.options(), w.get_text(w.get_start_iter(),
                                         w.get_end_iter(), False)]
        self.input_queue.put(nex)

    ###########################################################
    # Implementations of GTK signals defined in the Glade file

    def on_btnQuit_clicked(self, widget):
        self.input_queue.put([None, None]) #tell our translation thread to close
        self.save_config()
        Gtk.main_quit()

    def on_wndMain_destroy(self, widget):
        self.input_queue.put([None, None]) #tell our translation thread to end
        Gtk.main_quit()

    def on_wndMain_delete_event(self, widget, event):
        self.save_config()
        return False

    def on_btnAbout_clicked(self, widget):
        self.dlgAbout.show()

    def on_dlgAbout_response(self, widget, response):
        self.dlgAbout.hide()

    def update_translation_object(self, pair_name):
        """Given a language pair name like ab-cd, change - to _ so that
        one gets ab_cd. We must do this, because a D-Bus object name cannot
        contain dashes.

        Now, create a proxy object to the Apertium D-Bus translator object for
        the language pair and assign the object to self.translator."""
        global usingDbus
        if usingDbus:
            self.lang_pair = pair_name
            dbus_pair_name = "/" + "_".join(pair_name.split("-"))
            try:
                self.translator = dbus.Interface(self.bus.get_object("org.apertium.mode", dbus_pair_name), "org.apertium.Mode")
            except:
                usingDbus = False
        else:
            self.lang_pair = pair_name

    def on_comboPair_changed(self, widget):
        froLang = widget.get_active_iter()
        self.froLangCode = widget.get_model().get_value(froLang, 0)
        self.update_comboTo(self.froLangCode)
        self.buffer.emit("changed")

    def update_comboTo(self, froLang):
        toBox = self.glade.get_object("comboTo")
        toBox.remove_all()
        toBox.set_model(self.to[froLang])
        toBox.set_wrap_width(int(len(self.to[froLang]) / 6) + 1)
        toBox.set_active(0) # Set the combobox to the first entry
        
    def on_comboTo_changed(self, widget):
        toLangIter = widget.get_active_iter()
        if toLangIter is None:
            return
        
        self.toLangCode = widget.get_model().get_value(toLangIter, 0)
        toLang = self.toLangCode
        froLang = self.froLangCode
        if toLang is None or froLang is None:
            return #Don't do anything if either language list hasn't been
                    #populated yet
        pair_name = froLang + "-" + toLang        
        self.update_translation_object(pair_name)
        self.buffer.emit("changed")
    
    def on_chkMarkUnknown_toggled(self, widget):
        self.buffer.emit("changed")


if __name__ == "__main__":
    if len(sys.argv) > 1:
        print('apertium-tolk 0.2')
        print('Copyright (C) 2006 Wynand Winterbach')
        print('Copyright (C) 2012 Eric Ye')
        print('This is free software.  You may redistribute copies of it under the terms of')
        print('the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.')
        print('There is NO WARRANTY, to the extent permitted by law.')

        sys.exit(0)
    
    GObject.threads_init()
    wnd = MainWindow(tolk.datadir + "/apertium-tolk/glade/" + "tolk.ui")
    Gtk.main();

